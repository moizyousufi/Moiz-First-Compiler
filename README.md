## Package Management

We use [NPM](https://npmjs.com) for package management.
The package is initialized with:

~~~console
$> npm init
~~~

With default values given for the `package.json` file that is created.
In particular, a few scripts/sub-commands are given so that building, testing, _etc._, can be run via `npm run`.
See `package.json` to see what these commands do.

Note that the template uses the [Unlicense](https://unlicense.org) license which is replicated in `LICENSE`.
We recommend that you change the license as needed.

## Typescript

The Typescript compiler is installed as a (local) npm development package via `npm`:

~~~console
$> npm install typescript --save-dev
~~~

Development packages are packages that only used during program development, not program execution.

`tsconfig.json` contains default options to the Typescript compiler, `tsc`.
In particular, we specify that source files are contained in the `/src` directory and output files are placed in the `/dist` directory.
See the [tsconfig refeence](https://www.typescriptlang.org/tsconfig) for more information on these options.

## ESLint

We use [ESLint](https://eslint.org) to lint our code.
When coupled with appropriate Visual Studio Code plugin, ESLint provides strong support to enforce style and healthy code practices during development.
We installed `eslint` via the `eslint/config` helper tool:

~~~console
$> npm init @eslint/config
~~~

Arbitrarily, we chose the [Javascript Standard](https://standardjs.com) style for ESLint to enforce.
Feel free to customize this style template or choose a different style altogether.
`.eslintrc.js` contains these settings and the [ESLint user guide](https://eslint.org/docs/latest/use/configure/) provides a comprehensive reference for the file.

## Jest

We use [Jest](https://jestjs.io) as a testing framework for Typescript projects.
There are many such frameworks available; we choose Jest both because of its popularity and its ease of setup and use.

~~~console
$> npm install --save-dev jest ts-jest @types/jest
$> npx ts-jest config:init
~~~

The last command adds a Jest configuration file, `jest.config.js`, to the project.

## Devcontainer Configuration

The `/.devcontainer/devcontainer.json` file configures the runtime instance created when the project is loaded within a Github Codespace.
The file is the default configuration file provided by Microsoft in its [Node.js container template](https://github.com/microsoft/vscode-remote-try-node) with appropriate modifications for these kinds of projects.

Notably, if this project is run in a local version of Visual Studio Code, we recommend installing the following plugins to manage your work:

+   [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)
+   [Github Classroom](https://marketplace.visualstudio.com/items?itemName=GitHub.classroom)

## Git Configuration

`.gitignore` is pre-populated so that Git ignores all build files generated by the project.

# Final Language Design

I made many changes to my language. I ended up scrapping what I had and restarting entirely, making the entirity of the updated language in less than two weeks, because I needed to fundamentally change my design style if I wanted to implement sensible syntax. For now, I've made a language that only has addition, but with integers and floating point values. I have successfully implemented objects with single inheritence based off of a prototype model. Based off what I have, the language does not particularly require semicolons, but it is optional, as a special feature I decided to add. Here is how the language is structured:

Suppose a,b are integers. Suppose c,d are floating point values.
a + b is valid
a + c is valid
c + d is valid

Parentheses are also supported to work as expected.

To initialize an object with values x and y, you would type:

{ x : 0 , y : 5 }

which sets x to be 0 and y to be 5

Moreover, you can use inheritence as follows:

{ x : 0 , y : 5 , { z : 10 } }

To declare variables, I have created the 'Define' operator to be used for a variable x as follows:

Define x 5

Or if we want to define an object y:

Define y { a : 20 , b : 30 }

And we can summon these variables with a 'Call' operator as follows:

Define x 5

Call x

This will return 5.

We can also summon the elements of an object with the 'Call' operator as follows:

Define y { a : 20 , b : 30 }

Call y . b

This will return 20.

# Future Steps

I plan on adding subtraction, multiplication, division, booleans, if-else statements, boolean operators, and public/privacy modifiers to the language going into the future, but these were things I simply did not have enough time to implement within less than two weeks, so I've gone ahead and submitted as is.

